<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculadora de Deformação de Viga</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        inter: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            max-width: 800px;
            width: 100%;
            background-color: #ffffff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            border: 1px solid #e2e8f0;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .input-group {
            margin-bottom: 0px; /* Reduced margin for better spacing with new layout */
        }
        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #334155;
        }
        .input-group input {
            width: 100%;
            padding: 12px;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            font-size: 1rem;
            color: #1e293b;
            transition: border-color 0.2s ease-in-out;
        }
        .input-group input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }
        .btn-calculate {
            width: 100%;
            padding: 14px;
            background-color: #3b82f6;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.125rem;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            box-shadow: 0 4px 10px rgba(59, 130, 246, 0.3);
        }
        .btn-calculate:hover {
            background-color: #2563eb;
            transform: translateY(-2px);
        }
        .btn-calculate:active {
            background-color: #1d4ed8;
            transform: translateY(0);
        }
        .result-box {
            margin-top: 10px; /* Adjusted margin */
            padding: 20px;
            background-color: #e0f2fe;
            border-radius: 8px;
            border: 1px solid #93c5fd;
            color: #1e40af;
            font-size: 1.1rem;
            font-weight: 600;
            text-align: center;
        }
        .error-message {
            margin-top: 10px; /* Adjusted margin */
            padding: 15px;
            background-color: #fee2e2;
            border-radius: 8px;
            border: 1px solid #ef4444;
            color: #dc2626;
            font-size: 1rem;
            font-weight: 500;
            text-align: center;
        }
        canvas {
            width: 100%;
            height: auto;
            background-color: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            margin-top: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }
        #deflectionDisplay {
            margin-top: 10px;
            padding: 10px;
            background-color: #ecfdf5;
            border-radius: 8px;
            border: 1px solid #34d399;
            color: #065f46;
            font-size: 1rem;
            text-align: center;
            font-weight: 500;
            min-height: 40px; /* Ensure space even when hidden */
            display: flex;
            align-items: center;
            justify-content: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-4">Calculadora de Deformação de Viga Cantilever</h1>

        <div class="input-grid grid grid-cols-1 md:grid-cols-2 gap-4">
            <div class="input-group">
                <label for="length">Comprimento da Viga (L) [metros]:</label>
                <input type="number" id="length" placeholder="Ex: 5" step="any" value="5">
            </div>

            <div class="input-group">
                <label for="base">Base da Seção (b) [metros]:</label>
                <input type="number" id="base" placeholder="Ex: 0.3" step="any" value="0.3">
            </div>

            <div class="input-group">
                <label for="height">Altura da Seção (h) [metros]:</label>
                <input type="number" id="height" placeholder="Ex: 0.6" step="any" value="0.6">
            </div>

            <div class="input-group">
                <label for="load">Carga Aplicada (P) [Newtons]:</label>
                <input type="number" id="load" placeholder="Ex: 10000" step="any" value="10000">
            </div>

            <div class="input-group">
                <label for="elasticity">Módulo de Elasticidade (E) [Pascals]:</label>
                <input type="number" id="elasticity" placeholder="Ex: 30e9" step="any" value="30e9">
            </div>

            <div class="input-group">
                <label for="pointX">Ponto de Estudo (x) [metros, de 0 (extremidade livre) a L (engaste)]:</label>
                <input type="number" id="pointX" placeholder="Ex: 0 (extremidade livre)" step="any" value="0">
            </div>
        </div>
        
        <button class="btn-calculate" onclick="calculateDeflectionAndDraw()">Calcular e Desenhar</button>

        <div id="result" class="result-box hidden">
            <p>A deformação no ponto x (da extremidade livre) é: <span id="deflectionValue"></span> metros.</p>
        </div>

        <div id="errorMessage" class="error-message hidden"></div>

        <canvas id="beamCanvas"></canvas>
        <div id="deflectionDisplay" class="hidden"></div>
    </div>

    <script>
        const canvas = document.getElementById('beamCanvas');
        const ctx = canvas.getContext('2d');
        const deflectionDisplay = document.getElementById('deflectionDisplay');

        // Global variables to store current beam properties for drawing
        let currentL = 0;
        let currentP = 0;
        let currentE = 0;
        let currentI = 0;

        /**
         * Calculates the deflection of a cantilever beam.
         * The formula used expects 'x' to be measured from the fixed end.
         * @param {number} x_from_fixed_end - The distance from the fixed end.
         * @param {number} L_val - The total length of the beam.
         * @param {number} P_val - The applied load at the free end.
         * @param {number} E_val - The modulus of elasticity.
         * @param {number} I_val - The moment of inertia.
         * @returns {number} The calculated deflection.
         */
        function getDeflectionValue(x_from_fixed_end, L_val, P_val, E_val, I_val) {
            if (E_val === 0 || I_val === 0) return 0; // Avoid division by zero
            // The updated formula: v = P/6EI * (-x^3 + 3L^2*x -2L^3)
            // 'x' in this formula is assumed to be measured from the fixed end.
            const deflection = (P_val / (6 * E_val * I_val)) * (-Math.pow(x_from_fixed_end, 3) + 3 * Math.pow(L_val, 2) * x_from_fixed_end - 2 * Math.pow(L_val, 3));
            return deflection;
        }

        function calculateDeflectionAndDraw() {
            // Get input values
            const L = parseFloat(document.getElementById('length').value);
            const b = parseFloat(document.getElementById('base').value);
            const h = parseFloat(document.getElementById('height').value);
            const P = parseFloat(document.getElementById('load').value);
            const E = parseFloat(document.getElementById('elasticity').value);
            // 'x_input_free_end' is the user's 'x' measured from the free end.
            const x_input_free_end = parseFloat(document.getElementById('pointX').value);

            // Get result and error elements
            const resultBox = document.getElementById('result');
            const errorMessage = document.getElementById('errorMessage');
            const deflectionValueSpan = document.getElementById('deflectionValue');

            // Hide previous results/errors and display
            resultBox.classList.add('hidden');
            errorMessage.classList.add('hidden');
            errorMessage.textContent = '';
            deflectionDisplay.classList.add('hidden');
            deflectionDisplay.textContent = '';


            // Input validation
            if (isNaN(L) || isNaN(b) || isNaN(h) || isNaN(P) || isNaN(E) || isNaN(x_input_free_end)) {
                errorMessage.textContent = 'Por favor, preencha todos os campos com valores numéricos válidos.';
                errorMessage.classList.remove('hidden');
                return;
            }

            if (L <= 0 || b <= 0 || h <= 0 || E <= 0) {
                errorMessage.textContent = 'Comprimento, base, altura e elasticidade devem ser valores positivos.';
                errorMessage.classList.remove('hidden');
                return;
            }

            // Validate x_input_free_end (from 0 at free end to L at fixed end)
            if (x_input_free_end < 0 || x_input_free_end > L) {
                errorMessage.textContent = 'O ponto de estudo (x) deve estar entre 0 (extremidade livre) e L (engaste).';
                errorMessage.classList.remove('hidden');
                return;
            }
            
            // Calculate moment of inertia (I) for a rectangular section
            // I = (b * h^3) / 12
            const I = (b * Math.pow(h, 3)) / 12;

            // Store current parameters for drawing
            currentL = L;
            currentP = P;
            currentE = E;
            currentI = I;

            // Convert user's 'x' (from free end) to 'x' measured from the fixed end for the formula
            const x_for_formula = L - x_input_free_end;

            // Calculate deflection for the specific 'x' from input
            const deflectionAtX = getDeflectionValue(x_for_formula, L, P, E, I);

            // Display the result for the specific 'x'
            deflectionValueSpan.textContent = deflectionAtX.toExponential(4); // Use scientific notation for clarity
            resultBox.classList.remove('hidden');

            // Draw the beam and deflection curve
            drawBeamAndDeflection();
        }

        function drawBeamAndDeflection() {
            if (currentL === 0 || currentP === 0 || currentE === 0 || currentI === 0) {
                // Don't draw if parameters are not set or invalid
                return;
            }

            // Set canvas resolution for drawing
            canvas.width = canvas.offsetWidth;
            canvas.height = 300; // Fixed height for visualization

            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

            const beamLengthPx = canvas.width * 0.8; // Use 80% of canvas width for beam
            const beamStartX = (canvas.width - beamLengthPx) / 2; // Left side of the beam drawing
            const beamBaseY = canvas.height / 2; // Mid-height of canvas

            // --- Draw Fixed Support (Engaste) on the RIGHT side ---
            ctx.strokeStyle = '#334155';
            ctx.fillStyle = '#64748b';
            const wallWidth = 20;
            const wallHeight = 80;
            // Position at the right end of the beam drawing
            ctx.fillRect(beamStartX + beamLengthPx, beamBaseY - wallHeight / 2, wallWidth, wallHeight);
            // Hatching for fixed support
            ctx.beginPath();
            for (let i = 0; i < wallHeight / 10; i++) {
                ctx.moveTo(beamStartX + beamLengthPx, beamBaseY - wallHeight / 2 + i * 10);
                ctx.lineTo(beamStartX + beamLengthPx + wallWidth, beamBaseY - wallHeight / 2 + i * 10 + 10);
            }
            ctx.stroke();

            // --- Draw Beam ---
            ctx.beginPath();
            ctx.strokeStyle = '#1e293b';
            ctx.lineWidth = 4;
            ctx.moveTo(beamStartX, beamBaseY); // Start at left (free end)
            ctx.lineTo(beamStartX + beamLengthPx, beamBaseY); // End at right (fixed end)
            ctx.stroke();

            // --- Draw Load (P) at the free end (LEFT side) ---
            ctx.beginPath();
            ctx.strokeStyle = '#ef4444';
            ctx.fillStyle = '#ef4444';
            ctx.lineWidth = 2;
            const arrowHeadSize = 10;
            // Line at the free end (left side of the beam)
            ctx.moveTo(beamStartX, beamBaseY - 30);
            ctx.lineTo(beamStartX, beamBaseY);
            // Arrowhead
            ctx.moveTo(beamStartX, beamBaseY);
            ctx.lineTo(beamStartX - arrowHeadSize / 2, beamBaseY - arrowHeadSize);
            ctx.moveTo(beamStartX, beamBaseY);
            ctx.lineTo(beamStartX + arrowHeadSize / 2, beamBaseY - arrowHeadSize);
            ctx.stroke();
            ctx.font = '14px Inter';
            ctx.fillText('P', beamStartX - 20, beamBaseY - 20); // Label 'P' to the left of the load

            // --- Draw L and X labels ---
            ctx.fillStyle = '#475569';
            ctx.font = '12px Inter';
            ctx.fillText('L', beamStartX + beamLengthPx / 2, beamBaseY + 20); // Label for L
            ctx.fillText('x=0', beamStartX - 10, beamBaseY + 15); // x=0 at free end (left)
            ctx.fillText('x=L', beamStartX + beamLengthPx - 10, beamBaseY + 15); // x=L at fixed end (right)


            // --- Plot Deflection Curve ---
            ctx.beginPath();
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]); // Dashed line for deflection

            // Determine max deflection for scaling
            let maxDeflection = 0;
            // Iterate through a finer resolution for better curve plotting
            for (let i = 0; i <= 100; i++) {
                const x_normalized_canvas = i / 100; // x from 0 (left) to 1 (right) on canvas
                // Convert canvas X (left-to-right) to formula's X (fixed-to-free, fixed end is right)
                const x_actual_from_fixed_end = (1 - x_normalized_canvas) * currentL;
                const deflection = getDeflectionValue(x_actual_from_fixed_end, currentL, currentP, currentE, currentI);
                if (Math.abs(deflection) > maxDeflection) {
                    maxDeflection = Math.abs(deflection);
                }
            }

            // A heuristic scale factor for visualization. Adjust as needed.
            // This ensures deflection is visible but not excessively large
            const deflectionScale = (maxDeflection > 0) ? (canvas.height * 0.4) / maxDeflection : 0;
            
            // Draw the curve
            // The starting point for the curve needs to be calculated based on x=L for the formula (which is x=0 on the canvas left)
            let initial_deflection_at_canvas_start = getDeflectionValue(currentL, currentL, currentP, currentE, currentI);
            ctx.moveTo(beamStartX, beamBaseY - (initial_deflection_at_canvas_start * deflectionScale)); 

            for (let i = 0; i <= 100; i++) {
                const x_normalized_canvas = i / 100; // x from 0 (left) to 1 (right) on canvas
                // Convert canvas X (left-to-right) to formula's X (fixed-to-free, fixed end is right)
                const x_actual_from_fixed_end = (1 - x_normalized_canvas) * currentL;
                const deflection = getDeflectionValue(x_actual_from_fixed_end, currentL, currentP, currentE, currentI);

                const plotX = beamStartX + x_normalized_canvas * beamLengthPx;
                // Deflection is likely negative (downwards), so subtract to move plotY down on the canvas.
                const plotY = beamBaseY - (deflection * deflectionScale); 

                if (i === 0) {
                    // Already moved to start, but ensure if loop logic changes later.
                    ctx.moveTo(plotX, plotY);
                } else {
                    ctx.lineTo(plotX, plotY);
                }
            }
            ctx.stroke();
            ctx.setLineDash([]); // Reset line dash

            // Display current beam parameters on the canvas for clarity
            ctx.fillStyle = '#475569';
            ctx.font = '12px Inter';
            ctx.fillText(`L: ${currentL.toFixed(2)} m`, 10, 20);
            ctx.fillText(`P: ${currentP.toExponential(2)} N`, 10, 40);
            ctx.fillText(`E: ${currentE.toExponential(2)} Pa`, 10, 60);
            ctx.fillText(`I: ${currentI.toExponential(2)} m⁴`, 10, 80);
        }

        // Mouse move event for interactive deflection display
        canvas.addEventListener('mousemove', function(event) {
            if (currentL === 0 || currentP === 0 || currentE === 0 || currentI === 0) {
                deflectionDisplay.classList.add('hidden');
                return;
            }

            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left; // X position relative to the canvas
            
            const beamLengthPx = canvas.width * 0.8;
            const beamStartX = (canvas.width - beamLengthPx) / 2;

            // Map mouseX (canvas coordinate from left) to its normalized position (0 to 1) on the beam
            let x_normalized_canvas_mouse = (mouseX - beamStartX) / beamLengthPx;
            
            // Clamp normalized position to be within [0, 1]
            x_normalized_canvas_mouse = Math.max(0, Math.min(1, x_normalized_canvas_mouse));

            // Convert canvas X (left-to-right) to formula's X (fixed-to-free, fixed end is right)
            const x_from_fixed_end_mapped = (1 - x_normalized_canvas_mouse) * currentL;

            // Calculate deflection using 'x' from fixed end for the formula
            const deflection = getDeflectionValue(x_from_fixed_end_mapped, currentL, currentP, currentE, currentI);

            // Convert 'x' from fixed end to 'x' from free end for display (user's perspective)
            const x_display_free_end = currentL - x_from_fixed_end_mapped;

            deflectionDisplay.classList.remove('hidden');
            deflectionDisplay.textContent = `Deformação em x = ${x_display_free_end.toFixed(2)} m (da extremidade livre): ${deflection.toExponential(4)} m`;

            // Redraw with highlight dot
            drawBeamAndDeflection();

            // Determine max deflection for scaling the dot position
            let maxDeflectionForDot = 0;
            for (let i = 0; i <= 100; i++) {
                const x_normalized = i / 100;
                const x_actual_from_fixed_end = (1 - x_normalized) * currentL; // x for formula
                const d = getDeflectionValue(x_actual_from_fixed_end, currentL, currentP, currentE, currentI);
                if (Math.abs(d) > maxDeflectionForDot) {
                    maxDeflectionForDot = Math.abs(d);
                }
            }
            const deflectionScaleForDot = (maxDeflectionForDot > 0) ? (canvas.height * 0.4) / maxDeflectionForDot : 0;

            ctx.beginPath();
            // Plot the dot at the correct deflected position on the canvas
            const dotPlotY = beamBaseY - (deflection * deflectionScaleForDot);
            ctx.arc(mouseX, dotPlotY, 5, 0, Math.PI * 2);
            ctx.fillStyle = '#f97316'; // Orange dot
            ctx.fill();
        });

        canvas.addEventListener('mouseout', function() {
            deflectionDisplay.classList.add('hidden');
            // Redraw to remove the highlight dot
            drawBeamAndDeflection();
        });

        // Initial draw on load (optional, or triggered by first calculation)
        window.onload = function() {
            // Set initial canvas dimensions to ensure it's drawn correctly on first load
            canvas.width = canvas.offsetWidth;
            canvas.height = 300;
            calculateDeflectionAndDraw(); // Calculate and draw with default values
        };
    </script>
</body>
</html>
